var ue=Object.defineProperty;var me=(r,t,e)=>t in r?ue(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var V=(r,t,e)=>me(r,typeof t!="symbol"?t+"":t,e);import{_ as fe}from"./index-C1iRGETr.js";import{r as x,j as Z,Z as he}from"./vendor-react-_vsaDC62.js";import{H as F}from"./vendor-DBgzFpze.js";const pe="video-cache",Ee=2,P="segments",R="manifests",U="video-tracking",ge=7*24*60*60*1e3,te=500*1024*1024,we=10;let K=null,G=null;function _(){return K?Promise.resolve(K):G||(G=new Promise((r,t)=>{const e=indexedDB.open(pe,Ee);e.onerror=()=>t(e.error),e.onsuccess=()=>{K=e.result,r(K)},e.onupgradeneeded=n=>{const o=n.target.result;n.oldVersion;let s;o.objectStoreNames.contains(P)?s=n.target.transaction.objectStore(P):(s=o.createObjectStore(P,{keyPath:"url"}),s.createIndex("timestamp","timestamp",{unique:!1})),s.indexNames.contains("videoId")||s.createIndex("videoId","videoId",{unique:!1});let d;o.objectStoreNames.contains(R)?d=n.target.transaction.objectStore(R):(d=o.createObjectStore(R,{keyPath:"url"}),d.createIndex("timestamp","timestamp",{unique:!1})),d.indexNames.contains("videoId")||d.createIndex("videoId","videoId",{unique:!1}),o.objectStoreNames.contains(U)||o.createObjectStore(U,{keyPath:"videoId"}).createIndex("lastAccessed","lastAccessed",{unique:!1})}}),G)}function ye(r){try{const t=r.match(/videodelivery\.net\/([^\/]+)\//);if(t)return t[1];const e=new URL(r),n=e.pathname.split("/").filter(o=>o);return n.length>0?e.origin+"/"+n[0]:e.origin}catch{return null}}async function ne(r,t=!1,e){const n=performance.now(),o=t?"MANIFEST":"SEGMENT";try{const s=performance.now(),d=await _(),l=performance.now()-s;console.log(`[VIDEO CACHE] IndexedDB initialized in ${l.toFixed(2)}ms`);const a=t?R:P,f=d.transaction([a],"readonly").objectStore(a),h=Q(r,t),g=performance.now(),C=f.get(h);return new Promise(i=>{C.onsuccess=()=>{const w=performance.now()-g,S=performance.now()-n,y=C.result;if(!y){console.log(`[VIDEO CACHE] ${o} not found in cache (lookup took ${S.toFixed(2)}ms, request: ${w.toFixed(2)}ms)`),i(null);return}const $=Date.now()-y.timestamp;if($>ge){console.log(`[VIDEO CACHE] ${o} cache entry expired (age: ${($/1e3).toFixed(2)}s), deleting`),ae(r,t).catch(()=>{}),i(null);return}console.log(`[VIDEO CACHE] ${o} found in cache (lookup took ${S.toFixed(2)}ms, request: ${w.toFixed(2)}ms, size: ${y.data.byteLength} bytes, age: ${($/1e3).toFixed(2)}s)`),i(y.data)},C.onerror=()=>{const w=performance.now()-n;console.error(`[VIDEO CACHE] Error looking up ${o} after ${w.toFixed(2)}ms`),i(null)}})}catch(s){const d=performance.now()-n;return console.error(`[VIDEO CACHE] Exception during ${o} lookup after ${d.toFixed(2)}ms:`,s),null}}async function se(r,t,e=!1,n){const o=performance.now(),s=e?"MANIFEST":"SEGMENT";try{const d=performance.now(),l=await _(),a=performance.now()-d,p=e?R:P,h=l.transaction([p],"readwrite").objectStore(p),g=Q(r,e),C=n||ye(r),i={url:g,data:t,timestamp:Date.now(),size:t.byteLength,videoId:C||void 0},w=performance.now();await new Promise((y,$)=>{const b=h.put(i);b.onsuccess=()=>{const m=performance.now()-w;console.log(`[VIDEO CACHE] ${s} stored in IndexedDB in ${m.toFixed(2)}ms (size: ${t.byteLength} bytes)`),y()},b.onerror=()=>{const m=performance.now()-w;console.error(`[VIDEO CACHE] Error storing ${s} after ${m.toFixed(2)}ms:`,b.error),$(b.error)}});const S=performance.now()-o;console.log(`[VIDEO CACHE] Total ${s} cache write time: ${S.toFixed(2)}ms`),Ae().catch(()=>{})}catch(d){const l=performance.now()-o;console.error(`[VIDEO CACHE] Exception storing ${s} after ${l.toFixed(2)}ms:`,d)}}async function ae(r,t=!1){try{const e=await _(),n=t?R:P,s=e.transaction([n],"readwrite").objectStore(n),d=Q(r,t);await new Promise((l,a)=>{const p=s.delete(d);p.onsuccess=()=>l(),p.onerror=()=>a(p.error)})}catch{}}async function Se(){try{const r=await _();let t=0;for(const e of[P,R]){const s=r.transaction([e],"readonly").objectStore(e).getAll();await new Promise(d=>{s.onsuccess=()=>{const l=s.result;t+=l.reduce((a,p)=>a+p.size,0),d()},s.onerror=()=>d()})}return t}catch{return 0}}let X=!1,re=0;const Ce=5e3;async function Ae(){const r=Date.now();if(X||r-re<Ce)return;X=!0,re=r;const t=performance.now();try{const e=await Se();if(e<=te){X=!1;return}console.log(`[VIDEO CACHE] Starting cache cleanup (size: ${(e/1024/1024).toFixed(2)}MB, max: ${(te/1024/1024).toFixed(2)}MB)`);const n=await _(),o=[];for(const a of[P,R]){const p=a===R,g=n.transaction([a],"readonly").objectStore(a).index("timestamp");await new Promise(C=>{const i=g.openCursor();i.onsuccess=w=>{const S=w.target.result;if(S){const y=S.value;o.push({url:y.url,timestamp:y.timestamp,size:y.size,isManifest:p}),S.continue()}else C()},i.onerror=()=>C()})}let s=e,d=0;for(const a of o){if(s<=te*.8)break;await ae(a.url,a.isManifest),s-=a.size,d++}const l=performance.now()-t;console.log(`[VIDEO CACHE] Cache cleanup completed in ${l.toFixed(2)}ms (deleted ${d} entries, new size: ${(s/1024/1024).toFixed(2)}MB)`)}catch(e){const n=performance.now()-t;console.error(`[VIDEO CACHE] Cache cleanup error after ${n.toFixed(2)}ms:`,e)}finally{X=!1}}async function xe(r){try{const n=(await _()).transaction([U],"readwrite").objectStore(U),o={videoId:r,timestamp:Date.now(),lastAccessed:Date.now()};await new Promise((s,d)=>{const l=n.put(o);l.onsuccess=()=>s(),l.onerror=()=>d(l.error)})}catch{}}async function ve(r){try{const o=(await _()).transaction([U],"readonly").objectStore(U).index("lastAccessed");return new Promise(s=>{const d=o.openCursor(null,"prev"),l=[];d.onsuccess=a=>{const p=a.target.result;p&&l.length<r?(l.push(p.value.videoId),p.continue()):s(l)},d.onerror=()=>s([])})}catch{return[]}}async function $e(r){const t=performance.now();console.log(`[VIDEO CACHE] clearOldVideoCache called for currentVideoId=${r}`);try{const e=await _(),n=performance.now(),o=await ve(we),s=performance.now()-n,d=new Set([r,...o]);console.log(`[VIDEO CACHE] Keeping cache for ${d.size} videos: current=${r}, recent=${o.slice(0,5).join(", ")}${o.length>5?"...":""} (lookup took ${s.toFixed(2)}ms)`);let l=0,a=0;for(const f of[P,R]){const g=f===R?"MANIFEST":"SEGMENT",C=performance.now(),w=e.transaction([f],"readwrite").objectStore(f),S=w.index("videoId"),y=w.getAll();await new Promise($=>{y.onsuccess=async()=>{const b=y.result;a+=b.length;let m=0;console.log(`[VIDEO CACHE] Checking ${b.length} ${g} entries`);for(const v of b)v.videoId&&!d.has(v.videoId)&&await new Promise(z=>{const W=w.delete(v.url);W.onsuccess=()=>{m++,l++,z()},W.onerror=()=>z()});const I=performance.now()-C;console.log(`[VIDEO CACHE] ${g} store: checked ${b.length}, cleared ${m} (took ${I.toFixed(2)}ms)`),$()},y.onerror=()=>{console.error(`[VIDEO CACHE] Error getting ${g} entries`),$()}})}const p=performance.now()-t;console.log(`[VIDEO CACHE] clearOldVideoCache completed in ${p.toFixed(2)}ms: checked ${a} entries, cleared ${l} entries`)}catch(e){const n=performance.now()-t;console.error(`[VIDEO CACHE] Error in clearOldVideoCache after ${n.toFixed(2)}ms:`,e)}}function ce(r){return r.includes(".m3u8")||r.endsWith("/manifest")}function Q(r,t){if(t)try{const e=new URL(r),n=new URLSearchParams(e.search),o=Array.from(n.entries()).sort(([s],[d])=>s.localeCompare(d));return e.search=new URLSearchParams(o).toString(),e.toString()}catch{return r}else try{const e=new URL(r);return e.origin+e.pathname}catch{const e=r.match(/^https?:\/\/[^\/]+(\/[^?]+)/i);return e?e[0]:r.split("?")[0]}}const be=Object.freeze(Object.defineProperty({__proto__:null,clearOldVideoCache:$e,getCached:ne,isManifest:ce,normalizeCacheKey:Q,setCached:se,trackVideoAccess:xe},Symbol.toStringTag,{value:"Module"}));class Le{constructor(){V(this,"cache",new Map);V(this,"maxSize",100);V(this,"maxAge",5*60*1e3)}get(t){const e=this.cache.get(t);return e?Date.now()-e.timestamp>this.maxAge?(this.cache.delete(t),null):(this.cache.delete(t),this.cache.set(t,e),e.data):null}set(t,e){if(this.cache.size>=this.maxSize){const n=this.cache.keys().next().value;n&&this.cache.delete(n)}this.cache.set(t,{data:e,timestamp:Date.now()})}clear(){this.cache.clear()}}const J=new Le;class ie{constructor(t){V(this,"context",null);V(this,"stats");V(this,"defaultLoader",null);V(this,"abortController",null);this.abortController=new AbortController,this.stats={aborted:!1,loaded:0,retry:0,total:0,chunkCount:0,bwEstimate:0,loading:{start:0,first:0,end:0},parsing:{start:0,end:0},buffering:{start:0,first:0,end:0}}}load(t,e,n){this.context=t;const o=t.url,s=ce(o),d=performance.now(),l=s?"MANIFEST":"SEGMENT";let a;try{const i=o.match(/videodelivery\.net\/([^\/]+)\//);i&&(a=i[1])}catch{}console.log(`[CACHE LOADER] Loading ${l}: ${o} at ${d.toFixed(2)}ms${a?` (videoId=${a})`:""}`);let p;try{const i=o.match(/videodelivery\.net\/([^\/]+)\//);i&&(p=i[1])}catch{}const f=performance.now(),h=J.get(o),g=performance.now()-f;if(h){const i=performance.now()-d;console.log(`[CACHE LOADER] ${l} found in memory cache in ${i.toFixed(2)}ms (lookup: ${g.toFixed(2)}ms)${a?` for videoId=${a}`:""}`);let w;s?w=new TextDecoder().decode(h):w=h;const S=performance.now();this.stats.loading.start=S,this.stats.loading.first=S,this.stats.loading.end=S,this.stats.loaded=h.byteLength,this.stats.total=h.byteLength,this.stats.aborted=!1;const y={data:w,url:o,code:200};n.onSuccess(y,this.stats,t,{});return}console.log(`[CACHE LOADER] ${l} not in memory cache (lookup took ${g.toFixed(2)}ms), checking IndexedDB`);const C=performance.now();ne(o,s).then(i=>{const w=performance.now()-C;if(i){const S=performance.now()-d;console.log(`[CACHE LOADER] ${l} found in IndexedDB cache in ${S.toFixed(2)}ms (lookup: ${w.toFixed(2)}ms)${a?` for videoId=${a} - THIS IS A CACHED RESOURCE FOR BACKWARD NAVIGATION`:""}`),J.set(o,i);let y;s?y=new TextDecoder().decode(i):y=i;const $=performance.now();this.stats.loading.start=$,this.stats.loading.first=$,this.stats.loading.end=$,this.stats.loaded=i.byteLength,this.stats.total=i.byteLength,this.stats.aborted=!1;const b={data:y,url:o,code:200};n.onSuccess(b,this.stats,t,{});return}console.log(`[CACHE LOADER] ${l} not in IndexedDB cache (lookup took ${w.toFixed(2)}ms), fetching from network`),this.fetchFromNetwork(o,s,t,e,n,p)}).catch(i=>{const w=performance.now()-C;console.error(`[CACHE LOADER] IndexedDB lookup error after ${w.toFixed(2)}ms:`,i),this.fetchFromNetwork(o,s,t,e,n,p)})}async fetchFromNetwork(t,e,n,o,s,d){var p;const l=performance.now(),a=e?"MANIFEST":"SEGMENT";console.log(`[CACHE LOADER] Fetching ${a} from network: ${t} at ${l.toFixed(2)}ms`);try{const f=this.abortController||new AbortController,h=await fetch(t,{method:n.method||"GET",headers:n.headers||{},signal:f.signal}).catch(v=>{throw v.name==="AbortError",v});if(!h.ok)throw new Error(`HTTP ${h.status}: ${h.statusText}`);let g;const C=h.headers.get("content-type")||"";e||C.includes("application/vnd.apple.mpegurl")||C.includes("text")?g=await h.text():g=await h.arrayBuffer();const i=performance.now(),w=i-l,S=typeof g=="string"?new TextEncoder().encode(g).length:g.byteLength;console.log(`[CACHE LOADER] ${a} fetched from network in ${w.toFixed(2)}ms, size: ${S} bytes`),this.stats.loading.start=l,this.stats.loading.first=l,this.stats.loading.end=i,this.stats.loaded=S,this.stats.total=S,this.stats.aborted=!1;const y=performance.now(),$=g instanceof ArrayBuffer?g:new TextEncoder().encode(g).buffer,b=performance.now();J.set(t,$);const m=performance.now()-b;console.log(`[CACHE LOADER] ${a} stored in memory cache in ${m.toFixed(2)}ms`),se(t,$,e,d).then(()=>{const v=performance.now()-y;console.log(`[CACHE LOADER] ${a} stored in IndexedDB in ${v.toFixed(2)}ms`)}).catch(v=>{console.error(`[CACHE LOADER] Error storing ${a} in IndexedDB:`,v)});const I={data:g,url:h.url,code:h.status};s.onSuccess(I,this.stats,n,{})}catch(f){const h=performance.now();if(this.stats.loading.start=l,this.stats.loading.first=l,this.stats.loading.end=h,this.stats.loaded=0,this.stats.total=0,f instanceof Error&&f.name==="AbortError")this.stats.aborted=!0,(p=s.onAbort)==null||p.call(s,this.stats,n,{});else if(!(f instanceof Error&&f.name==="AbortError")){this.stats.aborted=!1;const g=f instanceof Error?f:new Error("Network error");s.onError({code:0,text:g.message},n,{},this.stats)}}}abort(){this.abortController&&(this.abortController.abort(),this.abortController=new AbortController)}destroy(){this.abortController&&(this.abortController.abort(),this.abortController=null),this.context=null,this.defaultLoader=null,this.stats={aborted:!1,loaded:0,retry:0,total:0,chunkCount:0,bwEstimate:0,loading:{start:0,first:0,end:0},parsing:{start:0,end:0},buffering:{start:0,first:0,end:0}}}getStats(){return this.stats}getResponseHeader(t){return null}getCacheAge(){return null}}const Re=Object.freeze(Object.defineProperty({__proto__:null,CachedLoader:ie,memoryCache:J},Symbol.toStringTag,{value:"Module"})),De=({playbackUrl:r,streamUID:t,aspectRatio:e,preferNative:n=!1,autoplay:o=!1,loop:s=!1,muted:d=!1,controls:l=!0,onVideoRef:a,onClick:p,videoKey:f})=>{const[h,g]=x.useState(1.7777777777777777),C=typeof window<"u"&&window.matchMedia("(pointer: fine) and (min-width: 768px)").matches;x.useEffect(()=>{if(!C)return;const E=()=>g(window.innerWidth/Math.max(1,window.innerHeight));return E(),window.addEventListener("resize",E),()=>window.removeEventListener("resize",E)},[C]);const i=x.useRef(null),[w,S]=x.useState(null),y=x.useMemo(()=>{const E=1.3333333333333333,H=16/9,c=typeof e=="number"&&isFinite(e)&&e>0?e:null;if(c)return Math.min(H,Math.max(E,c));const T=C?h:16/9;return Math.min(H,Math.max(E,T))},[C,h,e]),b=`${w??y} / 1`,m=x.useMemo(()=>r||(t?`https://videodelivery.net/${t}/manifest/video.m3u8`:null),[r,t]),I=x.useRef(null),v=x.useMemo(()=>{if(!m)return null;try{const E=m.match(/videodelivery\.net\/([^\/]+)\//);return E?E[1]:m}catch{return m}},[m]);x.useEffect(()=>{if(!m||!v){console.log("[PLAYER] No hlsUrl or videoId, skipping cache tracking");return}const E=I.current&&I.current!==m,H=!I.current,c=I.current&&I.current===m;console.log(`[PLAYER] Video change detected: hlsUrl=${m}, videoId=${v}`),console.log(`[PLAYER] Previous hlsUrl=${I.current||"null"}, isVideoChange=${E}, isInitialMount=${H}, isReturningToVideo=${c}`),fe(async()=>{const{trackVideoAccess:T,clearOldVideoCache:A}=await Promise.resolve().then(()=>be);return{trackVideoAccess:T,clearOldVideoCache:A}},void 0).then(({trackVideoAccess:T,clearOldVideoCache:A})=>{const M=performance.now();if(T(v).then(()=>{const D=performance.now()-M;console.log(`[PLAYER] Tracked video access for ${v} in ${D.toFixed(2)}ms`)}).catch(D=>{console.error("[PLAYER] Error tracking video access:",D)}),E&&!c){const D=performance.now();console.log(`[PLAYER] Clearing old video cache (switching from ${I.current} to ${m})`),A(v).then(()=>{const B=performance.now()-D;console.log(`[PLAYER] Old video cache cleared in ${B.toFixed(2)}ms`)}).catch(B=>{console.error("[PLAYER] Error clearing old video cache:",B)})}else console.log(`[PLAYER] Skipping cache clear: isVideoChange=${E}, isReturningToVideo=${c}`)}),I.current=m},[m,v]),x.useEffect(()=>{S(null)},[m]),x.useEffect(()=>{if(!n||!i.current)return;const E=i.current;let H=!1;const c=()=>{if(!H)if(E.videoWidth>0&&E.videoHeight>0){const T=E.videoWidth/E.videoHeight,A=4/3,M=16/9,D=Math.min(M,Math.max(A,T));S(D),H=!0}else S(y),H=!0};return E.addEventListener("loadedmetadata",c),E.readyState>=1&&c(),()=>{E.removeEventListener("loadedmetadata",c)}},[n,y,m]);const z=x.useRef(null);x.useEffect(()=>{if(!m){console.log("[HLS] No hlsUrl provided, skipping HLS setup");return}const E=z.current===m,H=z.current;console.log(`[HLS] HLS effect triggered: hlsUrl=${m}, prevHlsUrl=${H||"null"}, isReturningToVideo=${E}`),z.current=m;let c=null,T=null,A=!1,M=null;const D=()=>{if(document.hidden&&c){const u=i.current;if(u)try{u.pause()}catch{}try{c.stopLoad()}catch{}}},B=()=>{if(A=!0,c){try{c.stopLoad(),c.detachMedia(),c.destroy()}catch{}c=null}};document.addEventListener("visibilitychange",D),window.addEventListener("beforeunload",B);const de=()=>{const u=i.current;if(!u||A){console.warn(`[HLS] Cannot setup HLS: video=${!!u}, isCleanedUp=${A}`);return}const N=performance.now();if(console.log(`[HLS] Starting HLS setup for ${m} at ${N.toFixed(2)}ms`),console.log(`[HLS] Previous URL was: ${H||"null"}, isReturningToVideo=${E}`),console.log(`[HLS] Video element ready: readyState=${u.readyState}, paused=${u.paused}, currentTime=${u.currentTime.toFixed(2)}s`),F.isSupported()){console.log("[HLS] HLS.js is supported, creating instance");const Y={enableWorker:!0,lowLatencyMode:!1,backBufferLength:90,startLevel:-1,maxBufferLength:20,maxMaxBufferLength:60,maxBufferSize:60*1e3*1e3,maxBufferHole:.3,maxLoadingDelay:2,startFragPrefetch:!0,abrBandWidthFactor:.95,abrBandWidthUpFactor:.7,maxFragLoadingTimeMs:2e4,fragLoadingTimeOut:2e4,manifestLoadingTimeOut:1e4,manifestLoadingMaxRetry:1,fragLoadingMaxRetry:3,loader:ie};try{const q=performance.now();c=new F(Y);const j=performance.now()-q;console.log(`[HLS] HLS instance created in ${j.toFixed(2)}ms`);const L=performance.now();c.loadSource(m);const O=performance.now()-L;console.log(`[HLS] loadSource() called in ${O.toFixed(2)}ms`);const k=performance.now();c.attachMedia(u);const ee=performance.now()-k;console.log(`[HLS] attachMedia() completed in ${ee.toFixed(2)}ms`);const le=performance.now()-N;console.log(`[HLS] Total HLS setup time: ${le.toFixed(2)}ms`)}catch(q){const j=performance.now()-N;if(console.error(`[HLS] Failed to initialize HLS after ${j.toFixed(2)}ms:`,q),c){try{c.destroy()}catch{}c=null}return}c.on(F.Events.MANIFEST_PARSED,()=>{const q=performance.now()-N;if(console.log(`[HLS] MANIFEST_PARSED event fired at ${q.toFixed(2)}ms after setup start`),console.log(`[HLS] This indicates manifest was loaded ${E?"(should be from cache for returning video)":"(may be from network or cache)"}`),A||!u){console.warn("[HLS] MANIFEST_PARSED but video is cleaned up or missing");return}s&&(M=()=>{if(!(A||!u||!c))try{c.stopLoad(),u.currentTime=0,c.startLoad(),u.play().catch(L=>{L.name!=="AbortError"&&L.name!=="NotAllowedError"&&console.debug("Loop play failed:",L)})}catch{u.currentTime=0,u.play().catch(()=>{})}},u.addEventListener("ended",M)),(()=>{if(!(A||!u))if(u.readyState>=2){if(o){const L=performance.now();u.play().then(()=>{const O=performance.now()-L;console.log(`[HLS] Autoplay succeeded in ${O.toFixed(2)}ms after MANIFEST_PARSED`)}).catch(O=>{const k=performance.now()-L;O.name!=="AbortError"&&O.name!=="NotAllowedError"&&console.warn(`[HLS] Autoplay prevented after ${k.toFixed(2)}ms:`,O)})}}else{const L=()=>{if(!(A||!u)&&(u.removeEventListener("canplay",L),o)){const O=performance.now();u.play().then(()=>{const k=performance.now()-O;console.log(`[HLS] Autoplay succeeded in ${k.toFixed(2)}ms after canplay event`)}).catch(k=>{const ee=performance.now()-O;k.name!=="AbortError"&&k.name!=="NotAllowedError"&&console.warn(`[HLS] Autoplay prevented after ${ee.toFixed(2)}ms:`,k)})}};u.addEventListener("canplay",L,{once:!0})}})()}),c.on(F.Events.ERROR,(q,j)=>{if(!A&&j.fatal)switch(j.type){case F.ErrorTypes.NETWORK_ERROR:if(!A&&c)try{c.startLoad()}catch{}break;case F.ErrorTypes.MEDIA_ERROR:if(!A&&c)try{c.recoverMediaError()}catch{}break;default:c&&(c.destroy(),c=null);break}})}else A||console.warn("HLS.js not supported, falling back to native HLS (no caching)"),u.src=m,T=()=>{A||console.warn("Native HLS playback failed")},u.addEventListener("error",T),o&&!A&&u.play().catch(Y=>{Y.name!=="AbortError"&&Y.name!=="NotAllowedError"&&console.debug("Autoplay prevented:",Y)})};return A||requestAnimationFrame(()=>{requestAnimationFrame(()=>{!A&&i.current&&(de(),a&&a(i.current))})}),()=>{A=!0,document.removeEventListener("visibilitychange",D),window.removeEventListener("beforeunload",B);const u=i.current;if(u&&M&&(u.removeEventListener("ended",M),M=null),c){try{c.off(F.Events.MANIFEST_PARSED),c.off(F.Events.ERROR),c.off(F.Events.MEDIA_ATTACHED),c.off(F.Events.MEDIA_DETACHED),c.off(F.Events.MANIFEST_LOADED),c.stopLoad(),c.detachMedia(),c.destroy()}catch{}c=null}if(u){T&&(u.removeEventListener("error",T),T=null);try{for(u.pause(),u.currentTime=0,u.src="",u.srcObject=null;u.firstChild;)u.removeChild(u.firstChild);u.load()}catch{}}console.log(`[HLS] Cleanup completed for ${m}`)}},[m,o]),x.useEffect(()=>{a&&(a(i.current),i.current||requestAnimationFrame(()=>{requestAnimationFrame(()=>{i.current&&a&&a(i.current)})}))},[a,n,m,f]),x.useEffect(()=>{const E=i.current;E&&a&&a(E)},[a]);const W="100%",oe=C?{width:"100%",maxWidth:W,maxHeight:"100%",aspectRatio:b,background:"#000",borderRadius:10,overflow:"hidden",display:"flex",boxSizing:"border-box"}:{width:"auto",maxWidth:W,maxHeight:"100%",height:"var(--player-height)",aspectRatio:b,background:"#000",borderRadius:10,overflow:"hidden",display:"flex",boxSizing:"border-box"};return m?Z.jsx("div",{style:oe,children:Z.jsx("video",{ref:i,autoPlay:o,loop:!1,muted:d,controls:l,playsInline:!0,style:{width:"100%",height:"100%",objectFit:"contain",background:"#000",cursor:p?"pointer":"default"},children:"Your browser does not support the video tag."},f!==void 0?`${m}-${f}`:m)}):Z.jsx("div",{style:oe,children:"No video available"})},Oe=({open:r,onClose:t,buttonRef:e,children:n,align:o="right",minWidth:s=160})=>{const[d,l]=x.useState(null),a=x.useRef(null);if(x.useEffect(()=>{if(!r||!e.current){l(null);return}const f=()=>{if(!e.current)return;const h=e.current.getBoundingClientRect();l({top:h.bottom+8,[o]:window.innerWidth-h[o==="right"?"right":"left"]})};return f(),window.addEventListener("resize",f),window.addEventListener("scroll",f,!0),()=>{window.removeEventListener("resize",f),window.removeEventListener("scroll",f,!0)}},[r,e,o]),x.useEffect(()=>{if(!r)return;const f=h=>{a.current&&!a.current.contains(h.target)&&e.current&&!e.current.contains(h.target)&&t()};return document.addEventListener("mousedown",f),()=>document.removeEventListener("mousedown",f)},[r,t,e]),!r||!d)return null;const p=Z.jsx("div",{ref:a,style:{position:"fixed",top:d.top,[o]:d[o],background:"var(--panel)",border:"1px solid rgba(255,255,255,0.08)",borderRadius:10,padding:6,zIndex:1e3,minWidth:s,boxShadow:"0 12px 30px rgba(0,0,0,0.4)"},children:n});return he.createPortal(p,document.body)};export{De as P,Oe as a,Re as h,be as v};
