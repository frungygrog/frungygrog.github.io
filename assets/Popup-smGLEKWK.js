var ue=Object.defineProperty;var me=(n,t,e)=>t in n?ue(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var V=(n,t,e)=>me(n,typeof t!="symbol"?t+"":t,e);import{_ as fe}from"./index-BsUuZRyO.js";import{r as A,j as J,Z as he}from"./vendor-react-_vsaDC62.js";import{H as F}from"./vendor-DBgzFpze.js";const pe="video-cache",ge=2,P="segments",O="manifests",U="video-tracking",Ee=7*24*60*60*1e3,oe=500*1024*1024,we=10;let G=null,X=null;function _(){return G?Promise.resolve(G):X||(X=new Promise((n,t)=>{const e=indexedDB.open(pe,ge);e.onerror=()=>t(e.error),e.onsuccess=()=>{G=e.result,n(G)},e.onupgradeneeded=s=>{const r=s.target.result;s.oldVersion;let a;r.objectStoreNames.contains(P)?a=s.target.transaction.objectStore(P):(a=r.createObjectStore(P,{keyPath:"url"}),a.createIndex("timestamp","timestamp",{unique:!1})),a.indexNames.contains("videoId")||a.createIndex("videoId","videoId",{unique:!1});let d;r.objectStoreNames.contains(O)?d=s.target.transaction.objectStore(O):(d=r.createObjectStore(O,{keyPath:"url"}),d.createIndex("timestamp","timestamp",{unique:!1})),d.indexNames.contains("videoId")||d.createIndex("videoId","videoId",{unique:!1}),r.objectStoreNames.contains(U)||r.createObjectStore(U,{keyPath:"videoId"}).createIndex("lastAccessed","lastAccessed",{unique:!1})}}),X)}function ye(n){try{const t=n.match(/videodelivery\.net\/([^\/]+)\//);if(t)return t[1];const e=new URL(n),s=e.pathname.split("/").filter(r=>r);return s.length>0?e.origin+"/"+s[0]:e.origin}catch{return null}}async function se(n,t=!1,e){const s=performance.now(),r=t?"MANIFEST":"SEGMENT";try{const a=performance.now(),d=await _(),u=performance.now()-a;console.log(`[VIDEO CACHE] IndexedDB initialized in ${u.toFixed(2)}ms`);const c=t?O:P,f=d.transaction([c],"readonly").objectStore(c),h=ee(n,t),w=performance.now(),v=f.get(h);return new Promise(l=>{v.onsuccess=()=>{const y=performance.now()-w,C=performance.now()-s,S=v.result;if(!S){console.log(`[VIDEO CACHE] ${r} not found in cache (lookup took ${C.toFixed(2)}ms, request: ${y.toFixed(2)}ms)`),l(null);return}const L=Date.now()-S.timestamp;if(L>Ee){console.log(`[VIDEO CACHE] ${r} cache entry expired (age: ${(L/1e3).toFixed(2)}s), deleting`),ce(n,t).catch(()=>{}),l(null);return}console.log(`[VIDEO CACHE] ${r} found in cache (lookup took ${C.toFixed(2)}ms, request: ${y.toFixed(2)}ms, size: ${S.data.byteLength} bytes, age: ${(L/1e3).toFixed(2)}s)`),l(S.data)},v.onerror=()=>{const y=performance.now()-s;console.error(`[VIDEO CACHE] Error looking up ${r} after ${y.toFixed(2)}ms`),l(null)}})}catch(a){const d=performance.now()-s;return console.error(`[VIDEO CACHE] Exception during ${r} lookup after ${d.toFixed(2)}ms:`,a),null}}async function ae(n,t,e=!1,s){const r=performance.now(),a=e?"MANIFEST":"SEGMENT";try{const d=performance.now(),u=await _(),c=performance.now()-d,p=e?O:P,h=u.transaction([p],"readwrite").objectStore(p),w=ee(n,e),v=s||ye(n),l={url:w,data:t,timestamp:Date.now(),size:t.byteLength,videoId:v||void 0},y=performance.now();await new Promise((S,L)=>{const x=h.put(l);x.onsuccess=()=>{const m=performance.now()-y;console.log(`[VIDEO CACHE] ${a} stored in IndexedDB in ${m.toFixed(2)}ms (size: ${t.byteLength} bytes)`),S()},x.onerror=()=>{const m=performance.now()-y;console.error(`[VIDEO CACHE] Error storing ${a} after ${m.toFixed(2)}ms:`,x.error),L(x.error)}});const C=performance.now()-r;console.log(`[VIDEO CACHE] Total ${a} cache write time: ${C.toFixed(2)}ms`),ve().catch(()=>{})}catch(d){const u=performance.now()-r;console.error(`[VIDEO CACHE] Exception storing ${a} after ${u.toFixed(2)}ms:`,d)}}async function ce(n,t=!1){try{const e=await _(),s=t?O:P,a=e.transaction([s],"readwrite").objectStore(s),d=ee(n,t);await new Promise((u,c)=>{const p=a.delete(d);p.onsuccess=()=>u(),p.onerror=()=>c(p.error)})}catch{}}async function Se(){try{const n=await _();let t=0;for(const e of[P,O]){const a=n.transaction([e],"readonly").objectStore(e).getAll();await new Promise(d=>{a.onsuccess=()=>{const u=a.result;t+=u.reduce((c,p)=>c+p.size,0),d()},a.onerror=()=>d()})}return t}catch{return 0}}let Z=!1,ne=0;const Ce=5e3;async function ve(){const n=Date.now();if(Z||n-ne<Ce)return;Z=!0,ne=n;const t=performance.now();try{const e=await Se();if(e<=oe){Z=!1;return}console.log(`[VIDEO CACHE] Starting cache cleanup (size: ${(e/1024/1024).toFixed(2)}MB, max: ${(oe/1024/1024).toFixed(2)}MB)`);const s=await _(),r=[];for(const c of[P,O]){const p=c===O,w=s.transaction([c],"readonly").objectStore(c).index("timestamp");await new Promise(v=>{const l=w.openCursor();l.onsuccess=y=>{const C=y.target.result;if(C){const S=C.value;r.push({url:S.url,timestamp:S.timestamp,size:S.size,isManifest:p}),C.continue()}else v()},l.onerror=()=>v()})}let a=e,d=0;for(const c of r){if(a<=oe*.8)break;await ce(c.url,c.isManifest),a-=c.size,d++}const u=performance.now()-t;console.log(`[VIDEO CACHE] Cache cleanup completed in ${u.toFixed(2)}ms (deleted ${d} entries, new size: ${(a/1024/1024).toFixed(2)}MB)`)}catch(e){const s=performance.now()-t;console.error(`[VIDEO CACHE] Cache cleanup error after ${s.toFixed(2)}ms:`,e)}finally{Z=!1}}async function Ae(n){try{const s=(await _()).transaction([U],"readwrite").objectStore(U),r={videoId:n,timestamp:Date.now(),lastAccessed:Date.now()};await new Promise((a,d)=>{const u=s.put(r);u.onsuccess=()=>a(),u.onerror=()=>d(u.error)})}catch{}}async function $e(n){try{const r=(await _()).transaction([U],"readonly").objectStore(U).index("lastAccessed");return new Promise(a=>{const d=r.openCursor(null,"prev"),u=[];d.onsuccess=c=>{const p=c.target.result;p&&u.length<n?(u.push(p.value.videoId),p.continue()):a(u)},d.onerror=()=>a([])})}catch{return[]}}async function Le(n){const t=performance.now();console.log(`[VIDEO CACHE] clearOldVideoCache called for currentVideoId=${n}`);try{const e=await _(),s=performance.now(),r=await $e(we),a=performance.now()-s,d=new Set([n,...r]);console.log(`[VIDEO CACHE] Keeping cache for ${d.size} videos: current=${n}, recent=${r.slice(0,5).join(", ")}${r.length>5?"...":""} (lookup took ${a.toFixed(2)}ms)`);let u=0,c=0;for(const f of[P,O]){const w=f===O?"MANIFEST":"SEGMENT",v=performance.now(),y=e.transaction([f],"readwrite").objectStore(f),C=y.index("videoId"),S=y.getAll();await new Promise(L=>{S.onsuccess=async()=>{const x=S.result;c+=x.length;let m=0;console.log(`[VIDEO CACHE] Checking ${x.length} ${w} entries`);for(const $ of x)$.videoId&&!d.has($.videoId)&&await new Promise(z=>{const W=y.delete($.url);W.onsuccess=()=>{m++,u++,z()},W.onerror=()=>z()});const I=performance.now()-v;console.log(`[VIDEO CACHE] ${w} store: checked ${x.length}, cleared ${m} (took ${I.toFixed(2)}ms)`),L()},S.onerror=()=>{console.error(`[VIDEO CACHE] Error getting ${w} entries`),L()}})}const p=performance.now()-t;console.log(`[VIDEO CACHE] clearOldVideoCache completed in ${p.toFixed(2)}ms: checked ${c} entries, cleared ${u} entries`)}catch(e){const s=performance.now()-t;console.error(`[VIDEO CACHE] Error in clearOldVideoCache after ${s.toFixed(2)}ms:`,e)}}function ie(n){return n.includes(".m3u8")||n.endsWith("/manifest")}function ee(n,t){if(t)try{const e=new URL(n),s=new URLSearchParams(e.search),r=Array.from(s.entries()).sort(([a],[d])=>a.localeCompare(d));return e.search=new URLSearchParams(r).toString(),e.toString()}catch{return n}else try{const e=new URL(n);return e.origin+e.pathname}catch{const e=n.match(/^https?:\/\/[^\/]+(\/[^?]+)/i);return e?e[0]:n.split("?")[0]}}const xe=Object.freeze(Object.defineProperty({__proto__:null,clearOldVideoCache:Le,getCached:se,isManifest:ie,normalizeCacheKey:ee,setCached:ae,trackVideoAccess:Ae},Symbol.toStringTag,{value:"Module"}));class be{constructor(){V(this,"cache",new Map);V(this,"maxSize",100);V(this,"maxAge",5*60*1e3)}get(t){const e=this.cache.get(t);return e?Date.now()-e.timestamp>this.maxAge?(this.cache.delete(t),null):(this.cache.delete(t),this.cache.set(t,e),e.data):null}set(t,e){if(this.cache.size>=this.maxSize){const s=this.cache.keys().next().value;s&&this.cache.delete(s)}this.cache.set(t,{data:e,timestamp:Date.now()})}clear(){this.cache.clear()}}const Q=new be;class de{constructor(t){V(this,"context",null);V(this,"stats");V(this,"defaultLoader",null);V(this,"abortController",null);this.abortController=new AbortController,this.stats={aborted:!1,loaded:0,retry:0,total:0,chunkCount:0,bwEstimate:0,loading:{start:0,first:0,end:0},parsing:{start:0,end:0},buffering:{start:0,first:0,end:0}}}load(t,e,s){this.context=t;const r=t.url,a=ie(r),d=performance.now(),u=a?"MANIFEST":"SEGMENT";let c;try{const l=r.match(/videodelivery\.net\/([^\/]+)\//);l&&(c=l[1])}catch{}console.log(`[CACHE LOADER] Loading ${u}: ${r} at ${d.toFixed(2)}ms${c?` (videoId=${c})`:""}`);let p;try{const l=r.match(/videodelivery\.net\/([^\/]+)\//);l&&(p=l[1])}catch{}const f=performance.now(),h=Q.get(r),w=performance.now()-f;if(h){const l=performance.now()-d;console.log(`[CACHE LOADER] ${u} found in memory cache in ${l.toFixed(2)}ms (lookup: ${w.toFixed(2)}ms)${c?` for videoId=${c}`:""}`);let y;a?y=new TextDecoder().decode(h):y=h;const C=performance.now();this.stats.loading.start=C,this.stats.loading.first=C,this.stats.loading.end=C,this.stats.loaded=h.byteLength,this.stats.total=h.byteLength,this.stats.aborted=!1;const S={data:y,url:r,code:200};s.onSuccess(S,this.stats,t,{});return}console.log(`[CACHE LOADER] ${u} not in memory cache (lookup took ${w.toFixed(2)}ms), checking IndexedDB`);const v=performance.now();se(r,a).then(l=>{const y=performance.now()-v;if(l){const C=performance.now()-d;console.log(`[CACHE LOADER] ${u} found in IndexedDB cache in ${C.toFixed(2)}ms (lookup: ${y.toFixed(2)}ms)${c?` for videoId=${c} - THIS IS A CACHED RESOURCE FOR BACKWARD NAVIGATION`:""}`),Q.set(r,l);let S;a?S=new TextDecoder().decode(l):S=l;const L=performance.now();this.stats.loading.start=L,this.stats.loading.first=L,this.stats.loading.end=L,this.stats.loaded=l.byteLength,this.stats.total=l.byteLength,this.stats.aborted=!1;const x={data:S,url:r,code:200};s.onSuccess(x,this.stats,t,{});return}console.log(`[CACHE LOADER] ${u} not in IndexedDB cache (lookup took ${y.toFixed(2)}ms), fetching from network`),this.fetchFromNetwork(r,a,t,e,s,p)}).catch(l=>{const y=performance.now()-v;console.error(`[CACHE LOADER] IndexedDB lookup error after ${y.toFixed(2)}ms:`,l),this.fetchFromNetwork(r,a,t,e,s,p)})}async fetchFromNetwork(t,e,s,r,a,d){var p;const u=performance.now(),c=e?"MANIFEST":"SEGMENT";console.log(`[CACHE LOADER] Fetching ${c} from network: ${t} at ${u.toFixed(2)}ms`);try{const f=this.abortController||new AbortController,h=await fetch(t,{method:s.method||"GET",headers:s.headers||{},signal:f.signal}).catch($=>{throw $.name==="AbortError",$});if(!h.ok)throw new Error(`HTTP ${h.status}: ${h.statusText}`);let w;const v=h.headers.get("content-type")||"";e||v.includes("application/vnd.apple.mpegurl")||v.includes("text")?w=await h.text():w=await h.arrayBuffer();const l=performance.now(),y=l-u,C=typeof w=="string"?new TextEncoder().encode(w).length:w.byteLength;console.log(`[CACHE LOADER] ${c} fetched from network in ${y.toFixed(2)}ms, size: ${C} bytes`),this.stats.loading.start=u,this.stats.loading.first=u,this.stats.loading.end=l,this.stats.loaded=C,this.stats.total=C,this.stats.aborted=!1;const S=performance.now(),L=w instanceof ArrayBuffer?w:new TextEncoder().encode(w).buffer,x=performance.now();Q.set(t,L);const m=performance.now()-x;console.log(`[CACHE LOADER] ${c} stored in memory cache in ${m.toFixed(2)}ms`),ae(t,L,e,d).then(()=>{const $=performance.now()-S;console.log(`[CACHE LOADER] ${c} stored in IndexedDB in ${$.toFixed(2)}ms`)}).catch($=>{console.error(`[CACHE LOADER] Error storing ${c} in IndexedDB:`,$)});const I={data:w,url:h.url,code:h.status};a.onSuccess(I,this.stats,s,{})}catch(f){const h=performance.now();if(this.stats.loading.start=u,this.stats.loading.first=u,this.stats.loading.end=h,this.stats.loaded=0,this.stats.total=0,f instanceof Error&&f.name==="AbortError")this.stats.aborted=!0,(p=a.onAbort)==null||p.call(a,this.stats,s,{});else if(!(f instanceof Error&&f.name==="AbortError")){this.stats.aborted=!1;const w=f instanceof Error?f:new Error("Network error");a.onError({code:0,text:w.message},s,{},this.stats)}}}abort(){this.abortController&&(this.abortController.abort(),this.abortController=new AbortController)}destroy(){this.abortController&&(this.abortController.abort(),this.abortController=null),this.context=null,this.defaultLoader=null,this.stats={aborted:!1,loaded:0,retry:0,total:0,chunkCount:0,bwEstimate:0,loading:{start:0,first:0,end:0},parsing:{start:0,end:0},buffering:{start:0,first:0,end:0}}}getStats(){return this.stats}getResponseHeader(t){return null}getCacheAge(){return null}}const Oe=Object.freeze(Object.defineProperty({__proto__:null,CachedLoader:de,memoryCache:Q},Symbol.toStringTag,{value:"Module"})),Re=({playbackUrl:n,streamUID:t,aspectRatio:e,preferNative:s=!1,autoplay:r=!1,loop:a=!1,muted:d=!1,controls:u=!0,onVideoRef:c,onClick:p,videoKey:f})=>{const[h,w]=A.useState(1.7777777777777777),v=typeof window<"u"&&window.matchMedia("(pointer: fine) and (min-width: 768px)").matches;A.useEffect(()=>{if(!v)return;const g=()=>w(window.innerWidth/Math.max(1,window.innerHeight));return g(),window.addEventListener("resize",g),()=>window.removeEventListener("resize",g)},[v]);const l=A.useRef(null),[y,C]=A.useState(null),S=A.useMemo(()=>{const g=1.3333333333333333,H=16/9,i=typeof e=="number"&&isFinite(e)&&e>0?e:null;if(i)return Math.min(H,Math.max(g,i));const T=v?h:16/9;return Math.min(H,Math.max(g,T))},[v,h,e]),x=`${y??S} / 1`,m=A.useMemo(()=>n||(t?`https://videodelivery.net/${t}/manifest/video.m3u8`:null),[n,t]),I=A.useRef(null),$=A.useMemo(()=>{if(!m)return null;try{const g=m.match(/videodelivery\.net\/([^\/]+)\//);return g?g[1]:m}catch{return m}},[m]);A.useEffect(()=>{if(!m||!$){console.log("[PLAYER] No hlsUrl or videoId, skipping cache tracking");return}const g=I.current&&I.current!==m,H=!I.current,i=I.current&&I.current===m;console.log(`[PLAYER] Video change detected: hlsUrl=${m}, videoId=${$}`),console.log(`[PLAYER] Previous hlsUrl=${I.current||"null"}, isVideoChange=${g}, isInitialMount=${H}, isReturningToVideo=${i}`),fe(async()=>{const{trackVideoAccess:T,clearOldVideoCache:E}=await Promise.resolve().then(()=>xe);return{trackVideoAccess:T,clearOldVideoCache:E}},void 0).then(({trackVideoAccess:T,clearOldVideoCache:E})=>{const k=performance.now();if(T($).then(()=>{const R=performance.now()-k;console.log(`[PLAYER] Tracked video access for ${$} in ${R.toFixed(2)}ms`)}).catch(R=>{console.error("[PLAYER] Error tracking video access:",R)}),g&&!i){const R=performance.now();console.log(`[PLAYER] Clearing old video cache (switching from ${I.current} to ${m})`),E($).then(()=>{const B=performance.now()-R;console.log(`[PLAYER] Old video cache cleared in ${B.toFixed(2)}ms`)}).catch(B=>{console.error("[PLAYER] Error clearing old video cache:",B)})}else console.log(`[PLAYER] Skipping cache clear: isVideoChange=${g}, isReturningToVideo=${i}`)}),I.current=m},[m,$]),A.useEffect(()=>{C(null)},[m]),A.useEffect(()=>{if(!s||!l.current)return;const g=l.current;let H=!1;const i=()=>{if(!H)if(g.videoWidth>0&&g.videoHeight>0){const T=g.videoWidth/g.videoHeight,E=4/3,k=16/9,R=Math.min(k,Math.max(E,T));C(R),H=!0}else C(S),H=!0};return g.addEventListener("loadedmetadata",i),g.readyState>=1&&i(),()=>{g.removeEventListener("loadedmetadata",i)}},[s,S,m]);const z=A.useRef(null);A.useEffect(()=>{if(!m){console.log("[HLS] No hlsUrl provided, skipping HLS setup");return}const g=z.current===m,H=z.current;console.log(`[HLS] HLS effect triggered: hlsUrl=${m}, prevHlsUrl=${H||"null"}, isReturningToVideo=${g}`),z.current=m;let i=null,T=null,E=!1,k=null;const R=()=>{if(document.hidden&&i){const o=l.current;if(o)try{o.pause()}catch{}try{i.stopLoad()}catch{}}},B=()=>{if(E=!0,i){try{i.stopLoad(),i.detachMedia(),i.destroy()}catch{}i=null}};document.addEventListener("visibilitychange",R),window.addEventListener("beforeunload",B);const le=()=>{const o=l.current;if(!o||E){console.warn(`[HLS] Cannot setup HLS: video=${!!o}, isCleanedUp=${E}`);return}const N=performance.now();if(console.log(`[HLS] Starting HLS setup for ${m} at ${N.toFixed(2)}ms`),console.log(`[HLS] Previous URL was: ${H||"null"}, isReturningToVideo=${g}`),console.log(`[HLS] Video element ready: readyState=${o.readyState}, paused=${o.paused}, currentTime=${o.currentTime.toFixed(2)}s`),F.isSupported()){console.log("[HLS] HLS.js is supported, creating instance");const Y={enableWorker:!0,lowLatencyMode:!1,backBufferLength:90,startLevel:-1,maxBufferLength:20,maxMaxBufferLength:60,maxBufferSize:60*1e3*1e3,maxBufferHole:.3,maxLoadingDelay:2,startFragPrefetch:!0,abrBandWidthFactor:.95,abrBandWidthUpFactor:.7,maxFragLoadingTimeMs:2e4,fragLoadingTimeOut:2e4,manifestLoadingTimeOut:1e4,manifestLoadingMaxRetry:1,fragLoadingMaxRetry:3,loader:de};try{const q=performance.now();i=new F(Y);const j=performance.now()-q;console.log(`[HLS] HLS instance created in ${j.toFixed(2)}ms`);const b=performance.now();i.loadSource(m);const D=performance.now()-b;console.log(`[HLS] loadSource() called in ${D.toFixed(2)}ms`);const M=performance.now();i.attachMedia(o);const te=performance.now()-M;console.log(`[HLS] attachMedia() completed in ${te.toFixed(2)}ms`);const K=performance.now()-N;console.log(`[HLS] Total HLS setup time: ${K.toFixed(2)}ms`)}catch(q){const j=performance.now()-N;if(console.error(`[HLS] Failed to initialize HLS after ${j.toFixed(2)}ms:`,q),i){try{i.destroy()}catch{}i=null}return}i.on(F.Events.MANIFEST_PARSED,()=>{const q=performance.now()-N;if(console.log(`[HLS] MANIFEST_PARSED event fired at ${q.toFixed(2)}ms after setup start`),console.log(`[HLS] This indicates manifest was loaded ${g?"(should be from cache for returning video)":"(may be from network or cache)"}`),E||!o){console.warn("[HLS] MANIFEST_PARSED but video is cleaned up or missing");return}a&&(k=()=>{if(!(E||!o||!i))try{i.stopLoad(),o.currentTime=0,i.startLoad(),o.play().catch(b=>{b.name!=="AbortError"&&b.name!=="NotAllowedError"&&console.debug("Loop play failed:",b)})}catch{o.currentTime=0,o.play().catch(()=>{})}},o.addEventListener("ended",k)),(()=>{if(E||!o){console.log(`[HLS] Skipping autoplay: isCleanedUp=${E}, video=${!!o}`);return}const b=()=>{if(!(E||!o)&&(o.muted=d,r)){const D=performance.now();console.log(`[HLS] Attempting autoplay: readyState=${o.readyState}, paused=${o.paused}, muted=${o.muted}`),o.play().then(()=>{const M=performance.now()-D;console.log(`[HLS] Autoplay succeeded in ${M.toFixed(2)}ms (readyState=${o.readyState})`)}).catch(M=>{const te=performance.now()-D;if(M.name!=="AbortError"&&M.name!=="NotAllowedError"&&(console.warn(`[HLS] Autoplay prevented after ${te.toFixed(2)}ms:`,M),o.readyState<3)){const K=()=>{E||!o||(o.removeEventListener("canplaythrough",K),r&&o.paused&&o.play().catch(()=>{}))};o.addEventListener("canplaythrough",K,{once:!0})}})}};if(o.readyState>=3)b();else if(o.readyState>=2){b();const D=()=>{E||!o||(o.removeEventListener("canplaythrough",D),r&&o.paused&&b())};o.addEventListener("canplaythrough",D,{once:!0})}else{const D=()=>{E||!o||(o.removeEventListener("canplay",D),b())};o.addEventListener("canplay",D,{once:!0});const M=()=>{E||!o||(o.removeEventListener("canplaythrough",M),r&&o.paused&&b())};o.addEventListener("canplaythrough",M,{once:!0})}})()}),i.on(F.Events.ERROR,(q,j)=>{if(!E&&j.fatal)switch(j.type){case F.ErrorTypes.NETWORK_ERROR:if(!E&&i)try{i.startLoad()}catch{}break;case F.ErrorTypes.MEDIA_ERROR:if(!E&&i)try{i.recoverMediaError()}catch{}break;default:i&&(i.destroy(),i=null);break}})}else E||console.warn("HLS.js not supported, falling back to native HLS (no caching)"),o.src=m,T=()=>{E||console.warn("Native HLS playback failed")},o.addEventListener("error",T),r&&!E&&o.play().catch(Y=>{Y.name!=="AbortError"&&Y.name!=="NotAllowedError"&&console.debug("Autoplay prevented:",Y)})};return E||requestAnimationFrame(()=>{requestAnimationFrame(()=>{!E&&l.current&&(le(),c&&c(l.current))})}),()=>{E=!0,document.removeEventListener("visibilitychange",R),window.removeEventListener("beforeunload",B);const o=l.current;if(o&&k&&(o.removeEventListener("ended",k),k=null),i){try{i.off(F.Events.MANIFEST_PARSED),i.off(F.Events.ERROR),i.off(F.Events.MEDIA_ATTACHED),i.off(F.Events.MEDIA_DETACHED),i.off(F.Events.MANIFEST_LOADED),i.stopLoad(),i.detachMedia(),i.destroy()}catch{}i=null}if(o){T&&(o.removeEventListener("error",T),T=null);try{for(o.pause(),o.currentTime=0,o.src="",o.srcObject=null;o.firstChild;)o.removeChild(o.firstChild);o.load()}catch{}}console.log(`[HLS] Cleanup completed for ${m}`)}},[m,r]),A.useEffect(()=>{c&&(c(l.current),l.current||requestAnimationFrame(()=>{requestAnimationFrame(()=>{l.current&&c&&c(l.current)})}))},[c,s,m,f]),A.useEffect(()=>{const g=l.current;g&&c&&c(g)},[c]);const W="100%",re=v?{width:"100%",maxWidth:W,maxHeight:"100%",aspectRatio:x,background:"#000",borderRadius:10,overflow:"hidden",display:"flex",boxSizing:"border-box"}:{width:"auto",maxWidth:W,maxHeight:"100%",height:"var(--player-height)",aspectRatio:x,background:"#000",borderRadius:10,overflow:"hidden",display:"flex",boxSizing:"border-box"};return m?J.jsx("div",{style:re,children:J.jsx("video",{ref:l,autoPlay:r,loop:!1,muted:d,controls:u,playsInline:!0,style:{width:"100%",height:"100%",objectFit:"contain",background:"#000",cursor:p?"pointer":"default"},children:"Your browser does not support the video tag."},f!==void 0?`${m}-${f}`:m)}):J.jsx("div",{style:re,children:"No video available"})},De=({open:n,onClose:t,buttonRef:e,children:s,align:r="right",minWidth:a=160})=>{const[d,u]=A.useState(null),c=A.useRef(null);if(A.useEffect(()=>{if(!n||!e.current){u(null);return}const f=()=>{if(!e.current)return;const h=e.current.getBoundingClientRect();u({top:h.bottom+8,[r]:window.innerWidth-h[r==="right"?"right":"left"]})};return f(),window.addEventListener("resize",f),window.addEventListener("scroll",f,!0),()=>{window.removeEventListener("resize",f),window.removeEventListener("scroll",f,!0)}},[n,e,r]),A.useEffect(()=>{if(!n)return;const f=h=>{c.current&&!c.current.contains(h.target)&&e.current&&!e.current.contains(h.target)&&t()};return document.addEventListener("mousedown",f),()=>document.removeEventListener("mousedown",f)},[n,t,e]),!n||!d)return null;const p=J.jsx("div",{ref:c,style:{position:"fixed",top:d.top,[r]:d[r],background:"var(--panel)",border:"1px solid rgba(255,255,255,0.08)",borderRadius:10,padding:6,zIndex:1e3,minWidth:a,boxShadow:"0 12px 30px rgba(0,0,0,0.4)"},children:s});return he.createPortal(p,document.body)};export{Re as P,De as a,Oe as h,xe as v};
