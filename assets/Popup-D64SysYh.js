var ue=Object.defineProperty;var me=(r,t,e)=>t in r?ue(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var V=(r,t,e)=>me(r,typeof t!="symbol"?t+"":t,e);import{_ as fe}from"./index-DJK_lnyq.js";import{r as v,j as Z,Z as he}from"./vendor-react-_vsaDC62.js";import{H as R}from"./vendor-DBgzFpze.js";const pe="video-cache",ge=2,P="segments",F="manifests",U="video-tracking",Ee=7*24*60*60*1e3,te=500*1024*1024,we=10;let K=null,G=null;function _(){return K?Promise.resolve(K):G||(G=new Promise((r,t)=>{const e=indexedDB.open(pe,ge);e.onerror=()=>t(e.error),e.onsuccess=()=>{K=e.result,r(K)},e.onupgradeneeded=n=>{const o=n.target.result;n.oldVersion;let s;o.objectStoreNames.contains(P)?s=n.target.transaction.objectStore(P):(s=o.createObjectStore(P,{keyPath:"url"}),s.createIndex("timestamp","timestamp",{unique:!1})),s.indexNames.contains("videoId")||s.createIndex("videoId","videoId",{unique:!1});let c;o.objectStoreNames.contains(F)?c=n.target.transaction.objectStore(F):(c=o.createObjectStore(F,{keyPath:"url"}),c.createIndex("timestamp","timestamp",{unique:!1})),c.indexNames.contains("videoId")||c.createIndex("videoId","videoId",{unique:!1}),o.objectStoreNames.contains(U)||o.createObjectStore(U,{keyPath:"videoId"}).createIndex("lastAccessed","lastAccessed",{unique:!1})}}),G)}function ye(r){try{const t=r.match(/videodelivery\.net\/([^\/]+)\//);if(t)return t[1];const e=new URL(r),n=e.pathname.split("/").filter(o=>o);return n.length>0?e.origin+"/"+n[0]:e.origin}catch{return null}}async function ne(r,t=!1,e){const n=performance.now(),o=t?"MANIFEST":"SEGMENT";try{const s=performance.now(),c=await _(),d=performance.now()-s;console.log(`[VIDEO CACHE] IndexedDB initialized in ${d.toFixed(2)}ms`);const i=t?F:P,h=c.transaction([i],"readonly").objectStore(i),f=Q(r,t),g=performance.now(),C=h.get(f);return new Promise(u=>{C.onsuccess=()=>{const E=performance.now()-g,S=performance.now()-n,w=C.result;if(!w){console.log(`[VIDEO CACHE] ${o} not found in cache (lookup took ${S.toFixed(2)}ms, request: ${E.toFixed(2)}ms)`),u(null);return}const $=Date.now()-w.timestamp;if($>Ee){console.log(`[VIDEO CACHE] ${o} cache entry expired (age: ${($/1e3).toFixed(2)}s), deleting`),ae(r,t).catch(()=>{}),u(null);return}console.log(`[VIDEO CACHE] ${o} found in cache (lookup took ${S.toFixed(2)}ms, request: ${E.toFixed(2)}ms, size: ${w.data.byteLength} bytes, age: ${($/1e3).toFixed(2)}s)`),u(w.data)},C.onerror=()=>{const E=performance.now()-n;console.error(`[VIDEO CACHE] Error looking up ${o} after ${E.toFixed(2)}ms`),u(null)}})}catch(s){const c=performance.now()-n;return console.error(`[VIDEO CACHE] Exception during ${o} lookup after ${c.toFixed(2)}ms:`,s),null}}async function se(r,t,e=!1,n){const o=performance.now(),s=e?"MANIFEST":"SEGMENT";try{const c=performance.now(),d=await _(),i=performance.now()-c,p=e?F:P,f=d.transaction([p],"readwrite").objectStore(p),g=Q(r,e),C=n||ye(r),u={url:g,data:t,timestamp:Date.now(),size:t.byteLength,videoId:C||void 0},E=performance.now();await new Promise((w,$)=>{const b=f.put(u);b.onsuccess=()=>{const m=performance.now()-E;console.log(`[VIDEO CACHE] ${s} stored in IndexedDB in ${m.toFixed(2)}ms (size: ${t.byteLength} bytes)`),w()},b.onerror=()=>{const m=performance.now()-E;console.error(`[VIDEO CACHE] Error storing ${s} after ${m.toFixed(2)}ms:`,b.error),$(b.error)}});const S=performance.now()-o;console.log(`[VIDEO CACHE] Total ${s} cache write time: ${S.toFixed(2)}ms`),Ae().catch(()=>{})}catch(c){const d=performance.now()-o;console.error(`[VIDEO CACHE] Exception storing ${s} after ${d.toFixed(2)}ms:`,c)}}async function ae(r,t=!1){try{const e=await _(),n=t?F:P,s=e.transaction([n],"readwrite").objectStore(n),c=Q(r,t);await new Promise((d,i)=>{const p=s.delete(c);p.onsuccess=()=>d(),p.onerror=()=>i(p.error)})}catch{}}async function Se(){try{const r=await _();let t=0;for(const e of[P,F]){const s=r.transaction([e],"readonly").objectStore(e).getAll();await new Promise(c=>{s.onsuccess=()=>{const d=s.result;t+=d.reduce((i,p)=>i+p.size,0),c()},s.onerror=()=>c()})}return t}catch{return 0}}let X=!1,re=0;const Ce=5e3;async function Ae(){const r=Date.now();if(X||r-re<Ce)return;X=!0,re=r;const t=performance.now();try{const e=await Se();if(e<=te){X=!1;return}console.log(`[VIDEO CACHE] Starting cache cleanup (size: ${(e/1024/1024).toFixed(2)}MB, max: ${(te/1024/1024).toFixed(2)}MB)`);const n=await _(),o=[];for(const i of[P,F]){const p=i===F,g=n.transaction([i],"readonly").objectStore(i).index("timestamp");await new Promise(C=>{const u=g.openCursor();u.onsuccess=E=>{const S=E.target.result;if(S){const w=S.value;o.push({url:w.url,timestamp:w.timestamp,size:w.size,isManifest:p}),S.continue()}else C()},u.onerror=()=>C()})}let s=e,c=0;for(const i of o){if(s<=te*.8)break;await ae(i.url,i.isManifest),s-=i.size,c++}const d=performance.now()-t;console.log(`[VIDEO CACHE] Cache cleanup completed in ${d.toFixed(2)}ms (deleted ${c} entries, new size: ${(s/1024/1024).toFixed(2)}MB)`)}catch(e){const n=performance.now()-t;console.error(`[VIDEO CACHE] Cache cleanup error after ${n.toFixed(2)}ms:`,e)}finally{X=!1}}async function xe(r){try{const n=(await _()).transaction([U],"readwrite").objectStore(U),o={videoId:r,timestamp:Date.now(),lastAccessed:Date.now()};await new Promise((s,c)=>{const d=n.put(o);d.onsuccess=()=>s(),d.onerror=()=>c(d.error)})}catch{}}async function ve(r){try{const o=(await _()).transaction([U],"readonly").objectStore(U).index("lastAccessed");return new Promise(s=>{const c=o.openCursor(null,"prev"),d=[];c.onsuccess=i=>{const p=i.target.result;p&&d.length<r?(d.push(p.value.videoId),p.continue()):s(d)},c.onerror=()=>s([])})}catch{return[]}}async function $e(r){const t=performance.now();console.log(`[VIDEO CACHE] clearOldVideoCache called for currentVideoId=${r}`);try{const e=await _(),n=performance.now(),o=await ve(we),s=performance.now()-n,c=new Set([r,...o]);console.log(`[VIDEO CACHE] Keeping cache for ${c.size} videos: current=${r}, recent=${o.slice(0,5).join(", ")}${o.length>5?"...":""} (lookup took ${s.toFixed(2)}ms)`);let d=0,i=0;for(const h of[P,F]){const g=h===F?"MANIFEST":"SEGMENT",C=performance.now(),E=e.transaction([h],"readwrite").objectStore(h),S=E.index("videoId"),w=E.getAll();await new Promise($=>{w.onsuccess=async()=>{const b=w.result;i+=b.length;let m=0;console.log(`[VIDEO CACHE] Checking ${b.length} ${g} entries`);for(const x of b)x.videoId&&!c.has(x.videoId)&&await new Promise(z=>{const W=E.delete(x.url);W.onsuccess=()=>{m++,d++,z()},W.onerror=()=>z()});const I=performance.now()-C;console.log(`[VIDEO CACHE] ${g} store: checked ${b.length}, cleared ${m} (took ${I.toFixed(2)}ms)`),$()},w.onerror=()=>{console.error(`[VIDEO CACHE] Error getting ${g} entries`),$()}})}const p=performance.now()-t;console.log(`[VIDEO CACHE] clearOldVideoCache completed in ${p.toFixed(2)}ms: checked ${i} entries, cleared ${d} entries`)}catch(e){const n=performance.now()-t;console.error(`[VIDEO CACHE] Error in clearOldVideoCache after ${n.toFixed(2)}ms:`,e)}}function ce(r){return r.includes(".m3u8")||r.endsWith("/manifest")}function Q(r,t){if(t)try{const e=new URL(r),n=new URLSearchParams(e.search),o=Array.from(n.entries()).sort(([s],[c])=>s.localeCompare(c));return e.search=new URLSearchParams(o).toString(),e.toString()}catch{return r}else try{const e=new URL(r);return e.origin+e.pathname}catch{const e=r.match(/^https?:\/\/[^\/]+(\/[^?]+)/i);return e?e[0]:r.split("?")[0]}}const be=Object.freeze(Object.defineProperty({__proto__:null,clearOldVideoCache:$e,getCached:ne,isManifest:ce,normalizeCacheKey:Q,setCached:se,trackVideoAccess:xe},Symbol.toStringTag,{value:"Module"}));class Le{constructor(){V(this,"cache",new Map);V(this,"maxSize",100);V(this,"maxAge",5*60*1e3)}get(t){const e=this.cache.get(t);return e?Date.now()-e.timestamp>this.maxAge?(this.cache.delete(t),null):(this.cache.delete(t),this.cache.set(t,e),e.data):null}set(t,e){if(this.cache.size>=this.maxSize){const n=this.cache.keys().next().value;n&&this.cache.delete(n)}this.cache.set(t,{data:e,timestamp:Date.now()})}clear(){this.cache.clear()}}const J=new Le;class ie{constructor(t){V(this,"context",null);V(this,"stats");V(this,"defaultLoader",null);V(this,"abortController",null);this.abortController=new AbortController,this.stats={aborted:!1,loaded:0,retry:0,total:0,chunkCount:0,bwEstimate:0,loading:{start:0,first:0,end:0},parsing:{start:0,end:0},buffering:{start:0,first:0,end:0}}}load(t,e,n){this.context=t;const o=t.url,s=ce(o),c=performance.now(),d=s?"MANIFEST":"SEGMENT";let i;try{const u=o.match(/videodelivery\.net\/([^\/]+)\//);u&&(i=u[1])}catch{}console.log(`[CACHE LOADER] Loading ${d}: ${o} at ${c.toFixed(2)}ms${i?` (videoId=${i})`:""}`);let p;try{const u=o.match(/videodelivery\.net\/([^\/]+)\//);u&&(p=u[1])}catch{}const h=performance.now(),f=J.get(o),g=performance.now()-h;if(f){const u=performance.now()-c;console.log(`[CACHE LOADER] ${d} found in memory cache in ${u.toFixed(2)}ms (lookup: ${g.toFixed(2)}ms)${i?` for videoId=${i}`:""}`);let E;s?E=new TextDecoder().decode(f):E=f;const S=performance.now();this.stats.loading.start=S,this.stats.loading.first=S,this.stats.loading.end=S,this.stats.loaded=f.byteLength,this.stats.total=f.byteLength,this.stats.aborted=!1;const w={data:E,url:o,code:200};n.onSuccess(w,this.stats,t,{});return}console.log(`[CACHE LOADER] ${d} not in memory cache (lookup took ${g.toFixed(2)}ms), checking IndexedDB`);const C=performance.now();ne(o,s).then(u=>{const E=performance.now()-C;if(u){const S=performance.now()-c;console.log(`[CACHE LOADER] ${d} found in IndexedDB cache in ${S.toFixed(2)}ms (lookup: ${E.toFixed(2)}ms)${i?` for videoId=${i} - THIS IS A CACHED RESOURCE FOR BACKWARD NAVIGATION`:""}`),J.set(o,u);let w;s?w=new TextDecoder().decode(u):w=u;const $=performance.now();this.stats.loading.start=$,this.stats.loading.first=$,this.stats.loading.end=$,this.stats.loaded=u.byteLength,this.stats.total=u.byteLength,this.stats.aborted=!1;const b={data:w,url:o,code:200};n.onSuccess(b,this.stats,t,{});return}console.log(`[CACHE LOADER] ${d} not in IndexedDB cache (lookup took ${E.toFixed(2)}ms), fetching from network`),this.fetchFromNetwork(o,s,t,e,n,p)}).catch(u=>{const E=performance.now()-C;console.error(`[CACHE LOADER] IndexedDB lookup error after ${E.toFixed(2)}ms:`,u),this.fetchFromNetwork(o,s,t,e,n,p)})}async fetchFromNetwork(t,e,n,o,s,c){var p;const d=performance.now(),i=e?"MANIFEST":"SEGMENT";console.log(`[CACHE LOADER] Fetching ${i} from network: ${t} at ${d.toFixed(2)}ms`);try{const h=this.abortController||new AbortController,f=await fetch(t,{method:n.method||"GET",headers:n.headers||{},signal:h.signal}).catch(x=>{throw x.name==="AbortError",x});if(!f.ok)throw new Error(`HTTP ${f.status}: ${f.statusText}`);let g;const C=f.headers.get("content-type")||"";e||C.includes("application/vnd.apple.mpegurl")||C.includes("text")?g=await f.text():g=await f.arrayBuffer();const u=performance.now(),E=u-d,S=typeof g=="string"?new TextEncoder().encode(g).length:g.byteLength;console.log(`[CACHE LOADER] ${i} fetched from network in ${E.toFixed(2)}ms, size: ${S} bytes`),this.stats.loading.start=d,this.stats.loading.first=d,this.stats.loading.end=u,this.stats.loaded=S,this.stats.total=S,this.stats.aborted=!1;const w=performance.now(),$=g instanceof ArrayBuffer?g:new TextEncoder().encode(g).buffer,b=performance.now();J.set(t,$);const m=performance.now()-b;console.log(`[CACHE LOADER] ${i} stored in memory cache in ${m.toFixed(2)}ms`),se(t,$,e,c).then(()=>{const x=performance.now()-w;console.log(`[CACHE LOADER] ${i} stored in IndexedDB in ${x.toFixed(2)}ms`)}).catch(x=>{console.error(`[CACHE LOADER] Error storing ${i} in IndexedDB:`,x)});const I={data:g,url:f.url,code:f.status};s.onSuccess(I,this.stats,n,{})}catch(h){const f=performance.now();if(this.stats.loading.start=d,this.stats.loading.first=d,this.stats.loading.end=f,this.stats.loaded=0,this.stats.total=0,h instanceof Error&&h.name==="AbortError")this.stats.aborted=!0,(p=s.onAbort)==null||p.call(s,this.stats,n,{});else if(!(h instanceof Error&&h.name==="AbortError")){this.stats.aborted=!1;const g=h instanceof Error?h:new Error("Network error");s.onError({code:0,text:g.message},n,{},this.stats)}}}abort(){this.abortController&&(this.abortController.abort(),this.abortController=new AbortController)}destroy(){this.abortController&&(this.abortController.abort(),this.abortController=null),this.context=null,this.defaultLoader=null,this.stats={aborted:!1,loaded:0,retry:0,total:0,chunkCount:0,bwEstimate:0,loading:{start:0,first:0,end:0},parsing:{start:0,end:0},buffering:{start:0,first:0,end:0}}}getStats(){return this.stats}getResponseHeader(t){return null}getCacheAge(){return null}}const Fe=Object.freeze(Object.defineProperty({__proto__:null,CachedLoader:ie,memoryCache:J},Symbol.toStringTag,{value:"Module"})),De=({playbackUrl:r,streamUID:t,aspectRatio:e,preferNative:n=!1,autoplay:o=!1,loop:s=!1,muted:c=!1,controls:d=!0,onVideoRef:i,onClick:p,videoKey:h})=>{const[f,g]=v.useState(1.7777777777777777),C=typeof window<"u"&&window.matchMedia("(pointer: fine) and (min-width: 768px)").matches;v.useEffect(()=>{if(!C)return;const y=()=>g(window.innerWidth/Math.max(1,window.innerHeight));return y(),window.addEventListener("resize",y),()=>window.removeEventListener("resize",y)},[C]);const u=v.useRef(null),[E,S]=v.useState(null),w=v.useMemo(()=>{const y=1.3333333333333333,H=16/9,a=typeof e=="number"&&isFinite(e)&&e>0?e:null;if(a)return Math.min(H,Math.max(y,a));const T=C?f:16/9;return Math.min(H,Math.max(y,T))},[C,f,e]),b=`${E??w} / 1`,m=v.useMemo(()=>r||(t?`https://videodelivery.net/${t}/manifest/video.m3u8`:null),[r,t]),I=v.useRef(null),x=v.useMemo(()=>{if(!m)return null;try{const y=m.match(/videodelivery\.net\/([^\/]+)\//);return y?y[1]:m}catch{return m}},[m]);v.useEffect(()=>{if(!m||!x){console.log("[PLAYER] No hlsUrl or videoId, skipping cache tracking");return}const y=I.current&&I.current!==m,H=!I.current,a=I.current&&I.current===m;console.log(`[PLAYER] Video change detected: hlsUrl=${m}, videoId=${x}`),console.log(`[PLAYER] Previous hlsUrl=${I.current||"null"}, isVideoChange=${y}, isInitialMount=${H}, isReturningToVideo=${a}`),fe(async()=>{const{trackVideoAccess:T,clearOldVideoCache:A}=await Promise.resolve().then(()=>be);return{trackVideoAccess:T,clearOldVideoCache:A}},void 0).then(({trackVideoAccess:T,clearOldVideoCache:A})=>{const M=performance.now();if(T(x).then(()=>{const D=performance.now()-M;console.log(`[PLAYER] Tracked video access for ${x} in ${D.toFixed(2)}ms`)}).catch(D=>{console.error("[PLAYER] Error tracking video access:",D)}),y&&!a){const D=performance.now();console.log(`[PLAYER] Clearing old video cache (switching from ${I.current} to ${m})`),A(x).then(()=>{const B=performance.now()-D;console.log(`[PLAYER] Old video cache cleared in ${B.toFixed(2)}ms`)}).catch(B=>{console.error("[PLAYER] Error clearing old video cache:",B)})}else console.log(`[PLAYER] Skipping cache clear: isVideoChange=${y}, isReturningToVideo=${a}`)}),I.current=m},[m,x]),v.useEffect(()=>{S(null)},[m]),v.useEffect(()=>{if(!n||!u.current)return;const y=u.current;let H=!1;const a=()=>{if(!H)if(y.videoWidth>0&&y.videoHeight>0){const T=y.videoWidth/y.videoHeight,A=4/3,M=16/9,D=Math.min(M,Math.max(A,T));S(D),H=!0}else S(w),H=!0};return y.addEventListener("loadedmetadata",a),y.readyState>=1&&a(),()=>{y.removeEventListener("loadedmetadata",a)}},[n,w,m]);const z=v.useRef(null);v.useEffect(()=>{if(!m){console.log("[HLS] No hlsUrl provided, skipping HLS setup");return}const y=z.current===m,H=z.current;console.log(`[HLS] HLS effect triggered: hlsUrl=${m}, prevHlsUrl=${H||"null"}, isReturningToVideo=${y}`),z.current=m;let a=null,T=null,A=!1,M=null;const D=()=>{if(document.hidden&&a){const l=u.current;if(l)try{l.pause()}catch{}try{a.stopLoad()}catch{}}},B=()=>{if(A=!0,a){try{a.stopLoad(),a.detachMedia(),a.destroy()}catch{}a=null}};document.addEventListener("visibilitychange",D),window.addEventListener("beforeunload",B);const de=()=>{const l=u.current;if(!l||A){console.warn(`[HLS] Cannot setup HLS: video=${!!l}, isCleanedUp=${A}`);return}const N=performance.now();if(console.log(`[HLS] Starting HLS setup for ${m} at ${N.toFixed(2)}ms`),console.log(`[HLS] Previous URL was: ${H||"null"}, isReturningToVideo=${y}`),console.log(`[HLS] Video element ready: readyState=${l.readyState}, paused=${l.paused}, currentTime=${l.currentTime.toFixed(2)}s`),R.isSupported()){console.log("[HLS] HLS.js is supported, creating instance");const Y={enableWorker:!0,lowLatencyMode:!1,backBufferLength:90,startLevel:-1,maxBufferLength:20,maxMaxBufferLength:60,maxBufferSize:60*1e3*1e3,maxBufferHole:.3,maxLoadingDelay:2,startFragPrefetch:!0,abrBandWidthFactor:.95,abrBandWidthUpFactor:.7,maxFragLoadingTimeMs:2e4,fragLoadingTimeOut:2e4,manifestLoadingTimeOut:1e4,manifestLoadingMaxRetry:1,fragLoadingMaxRetry:3,loader:ie};try{const q=performance.now();a=new R(Y);const j=performance.now()-q;console.log(`[HLS] HLS instance created in ${j.toFixed(2)}ms`);const L=performance.now();a.loadSource(m);const O=performance.now()-L;console.log(`[HLS] loadSource() called in ${O.toFixed(2)}ms`);const k=performance.now();a.attachMedia(l);const ee=performance.now()-k;console.log(`[HLS] attachMedia() completed in ${ee.toFixed(2)}ms`);const le=performance.now()-N;console.log(`[HLS] Total HLS setup time: ${le.toFixed(2)}ms`)}catch(q){const j=performance.now()-N;if(console.error(`[HLS] Failed to initialize HLS after ${j.toFixed(2)}ms:`,q),a){try{a.destroy()}catch{}a=null}return}a.on(R.Events.MANIFEST_PARSED,()=>{const q=performance.now()-N;if(console.log(`[HLS] MANIFEST_PARSED event fired at ${q.toFixed(2)}ms after setup start`),console.log(`[HLS] This indicates manifest was loaded ${y?"(should be from cache for returning video)":"(may be from network or cache)"}`),A||!l){console.warn("[HLS] MANIFEST_PARSED but video is cleaned up or missing");return}s&&(M=()=>{if(!(A||!l||!a))try{a.stopLoad(),l.currentTime=0,a.startLoad(),l.play().catch(L=>{L.name!=="AbortError"&&L.name!=="NotAllowedError"&&console.debug("Loop play failed:",L)})}catch{l.currentTime=0,l.play().catch(()=>{})}},l.addEventListener("ended",M)),(()=>{if(!(A||!l))if(l.readyState>=2){if(o){const L=performance.now();l.play().then(()=>{const O=performance.now()-L;console.log(`[HLS] Autoplay succeeded in ${O.toFixed(2)}ms after MANIFEST_PARSED`)}).catch(O=>{const k=performance.now()-L;O.name!=="AbortError"&&O.name!=="NotAllowedError"&&console.warn(`[HLS] Autoplay prevented after ${k.toFixed(2)}ms:`,O)})}}else{const L=()=>{if(!(A||!l)&&(l.removeEventListener("canplay",L),o)){const O=performance.now();l.play().then(()=>{const k=performance.now()-O;console.log(`[HLS] Autoplay succeeded in ${k.toFixed(2)}ms after canplay event`)}).catch(k=>{const ee=performance.now()-O;k.name!=="AbortError"&&k.name!=="NotAllowedError"&&console.warn(`[HLS] Autoplay prevented after ${ee.toFixed(2)}ms:`,k)})}};l.addEventListener("canplay",L,{once:!0})}})()}),a.on(R.Events.ERROR,(q,j)=>{if(!A&&j.fatal)switch(j.type){case R.ErrorTypes.NETWORK_ERROR:if(!A&&a)try{a.startLoad()}catch{}break;case R.ErrorTypes.MEDIA_ERROR:if(!A&&a)try{a.recoverMediaError()}catch{}break;default:a&&(a.destroy(),a=null);break}})}else A||console.warn("HLS.js not supported, falling back to native HLS (no caching)"),l.src=m,T=()=>{A||console.warn("Native HLS playback failed")},l.addEventListener("error",T),o&&!A&&l.play().catch(Y=>{Y.name!=="AbortError"&&Y.name!=="NotAllowedError"&&console.debug("Autoplay prevented:",Y)})};return A||requestAnimationFrame(()=>{!A&&u.current&&de()}),()=>{A=!0,document.removeEventListener("visibilitychange",D),window.removeEventListener("beforeunload",B);const l=u.current;if(l&&M&&(l.removeEventListener("ended",M),M=null),a){try{a.off(R.Events.MANIFEST_PARSED),a.off(R.Events.ERROR),a.off(R.Events.MEDIA_ATTACHED),a.off(R.Events.MEDIA_DETACHED),a.off(R.Events.MANIFEST_LOADED),a.stopLoad(),a.detachMedia(),a.destroy()}catch{}a=null}if(l){T&&(l.removeEventListener("error",T),T=null);try{for(l.pause(),l.currentTime=0,l.src="",l.srcObject=null;l.firstChild;)l.removeChild(l.firstChild);l.load()}catch{}}console.log(`[HLS] Cleanup completed for ${m}`)}},[m,o]),v.useEffect(()=>{i&&i(u.current)},[i,n,m]);const W="100%",oe=C?{width:"100%",maxWidth:W,maxHeight:"100%",aspectRatio:b,background:"#000",borderRadius:10,overflow:"hidden",display:"flex",boxSizing:"border-box"}:{width:"auto",maxWidth:W,maxHeight:"100%",height:"var(--player-height)",aspectRatio:b,background:"#000",borderRadius:10,overflow:"hidden",display:"flex",boxSizing:"border-box"};return m?Z.jsx("div",{style:oe,children:Z.jsx("video",{ref:u,autoPlay:o,loop:!1,muted:c,controls:d,playsInline:!0,style:{width:"100%",height:"100%",objectFit:"contain",background:"#000",cursor:p?"pointer":"default"},children:"Your browser does not support the video tag."},h!==void 0?`${m}-${h}`:m)}):Z.jsx("div",{style:oe,children:"No video available"})},Oe=({open:r,onClose:t,buttonRef:e,children:n,align:o="right",minWidth:s=160})=>{const[c,d]=v.useState(null),i=v.useRef(null);if(v.useEffect(()=>{if(!r||!e.current){d(null);return}const h=()=>{if(!e.current)return;const f=e.current.getBoundingClientRect();d({top:f.bottom+8,[o]:window.innerWidth-f[o==="right"?"right":"left"]})};return h(),window.addEventListener("resize",h),window.addEventListener("scroll",h,!0),()=>{window.removeEventListener("resize",h),window.removeEventListener("scroll",h,!0)}},[r,e,o]),v.useEffect(()=>{if(!r)return;const h=f=>{i.current&&!i.current.contains(f.target)&&e.current&&!e.current.contains(f.target)&&t()};return document.addEventListener("mousedown",h),()=>document.removeEventListener("mousedown",h)},[r,t,e]),!r||!c)return null;const p=Z.jsx("div",{ref:i,style:{position:"fixed",top:c.top,[o]:c[o],background:"var(--panel)",border:"1px solid rgba(255,255,255,0.08)",borderRadius:10,padding:6,zIndex:1e3,minWidth:s,boxShadow:"0 12px 30px rgba(0,0,0,0.4)"},children:n});return he.createPortal(p,document.body)};export{De as P,Oe as a,Fe as h,be as v};
